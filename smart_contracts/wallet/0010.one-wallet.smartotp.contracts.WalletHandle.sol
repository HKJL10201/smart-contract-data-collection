/**
 * Description:
 *   Smart contract wallet with 2-step authentication based on OTPs generated by CSPRNG and aggregated by Merkle tree.
 *
 */
pragma solidity ^0.5.8;

contract WalletHandle {
    uint8 constant MAX_LEN_OF_PROOF = 20; // delimits the max. height of subtree as well as height difference from the parent tree
    uint8 constant MIN_HEIGHT_SUBTREE = 1; // Min height of a subtree

    enum OperationType { TRANSFER, SET_DAILY_LIMIT, SET_LAST_RESORT_ADDRESS, SET_LAST_RESORT_TIMEOUT, DESTRUCT_WALLET, NOP}

    struct RequestedOperation {
        address payable addr; // depending on operation type: 1) address of the recepient of funds OR 2) address of the last ressort destination 3) Child root hash
        uint param; // depending on operation type: 1) amount to send to addr (in Wei), 2) new daily limit, 3) timeout of last resort, 4) depth of cached layer
        bool pending; // indicates whether operation is still pending or it was already confirmed
        OperationType operation; // indicates the type of authenticated operation
    }
    struct DailyLimits {
        uint dailyLimit; // in Ether. If it is zero than no daily limit is used. Can be modified only by special init/confirm method.
        uint dailyAlreadySpent; // in Ether. NOTE: this value can be stale when retrieving from client API (check always relatedDay)
        uint64 relatedDay; // as days since epoch (== timestamp / 1 days).
    }
    struct LastResortInfo {
        address payable addr; // this address is used for sending all the funds either after specified time of inactivity or depleting all the OTPs
        uint64 lastActiveDay; // as days since epoch (== timestamp / 1 days).
        uint64 timeoutDays; // selfdestruct can be called after this time interval, causing send of funds to addr. 0 means disabled last resort functionality.
    }

    address public owner;
    DailyLimits public dailyLimits; // This variable holds information about daily limits and expenses
    LastResortInfo public lastResort;
    RequestedOperation[] public pendingOpers; // pendingOpers.length is an increment only "pointer" to the actual leaf of paren MT, which is bounded to an operation with 2FA

    // MT info could be in a single or two structs, once ABI will be more mature.
    bytes16[] public MT_child_cachedLayer;
    bytes16 public MT_child_rootHash;
    uint8 public MT_child_height;    // The height of MT tree (e.g., MT with 8 leaves has height 3)
    uint8 public MT_child_depthOfCachedLayer; // The depth of 'MT_child_cachedLayer' from the top of MT
    uint32 public MT_child_numberOfOTPs; // this must not change ever
    uint16 public MT_hash_chain_len;

    bytes16 public MT_parent_rootHash;
    uint8  public MT_parent_height; // this is the whole height including the height of child trees
    uint32 public MT_parent_numberOfOTPs; // The number of OTPs in the parent MT. It is set in the constructor - once a lifetime of a contract.
    uint32 public MT_parent_currentChildTreeIdx = 0; // it is increment only
    uint32 public MT_parent_currentParentTreeIdx = 0; // it is increment only

    // Overhead for the operation adding a new parent root hash - can be modified only when last OTP of parent tree was reached
    bytes16[] public NewParentTree_1stStageBuffer; // contains entries in form: h(root_hash || last OTP)
    bytes16[] public NewParentTree_2ndStageBuffer; // contains root hash entries

    ///////////// Events for Client ////////////////
    event InitOperEvent(string message, address addr, uint32 otpID, uint param, OperationType operation);
    event DailyLimitChangedEvent(string message, uint new_daly_limit);
    event TransferEvent(string message, address recepient, uint amount);
    event LastResortAddrEvent(string message, address addr);
    event LastResortTimeoutEvent(string message, uint64 timeout);
    event DebugEvent(string message, bytes16 providedCM, bytes16 expectedCM);
    event DebugEvent2(string message, bytes16 confirmMatWithIndex);
    event DebugEvent3(string message, bytes32 concatenatedMaterial, bytes16 a, bytes16 b);
    event DebugEvent4(string message, bytes1 b);
    event DebugEvent5(string message, bytes16 providedToken, bytes16 expectedToken);
    event DebugEvent6(string message, bytes32 hashResult);
    event DebugEvent7(string message, uint32 expetedChIdx, uint32 providedChIdx);
    event DebugEvent8(string message, uint32 hashChainCnt);
    event UknownOperationEvent(string message);

    ///////////// Modifiers (working as macros) ////////////////
    modifier m_checkOnlyOwner {
        require(msg.sender == owner, "Only contract owner can call this function.");
        _;
    }

    modifier m_checkMaxMinHeight (uint8 requestedHeightChild) {
        require(requestedHeightChild <= MAX_LEN_OF_PROOF, "Currently, maximum height of child Merkle Tree is 20.");
        require(requestedHeightChild >= MIN_HEIGHT_SUBTREE, "Currently, minimum height of a child Merkle Tree is 1.");
        // log0(strToBytes32("Requirement m_checkMaxMinHeight satisfied..."));
        _;
    }
    modifier m_checkLengthOfCachedLayer (uint8 requestedHeight, uint8 _depthOfLayer,  bytes16[] memory providedLayerOfMT){
        require(providedLayerOfMT.length <= uint32(2) ** requestedHeight,
            "The provided cached layer does not fit boundaries of tree."
        );
        require(providedLayerOfMT.length == uint32(2) ** _depthOfLayer,
            "The length of provided cached layer does not correspond to its provided depth."
        );
        // log2(strToBytes32("Requirement on length of cached layer satisfied..."), bytes32(_depthOfLayer), bytes32(providedLayerOfMT.length));
        _;
    }
    modifier m_checkEnoughBallance(uint requestedAmount, OperationType operation) {
        if (OperationType.TRANSFER == operation) { // TODO: involve gas consumption here when settled
            require(requestedAmount <= address(this).balance,
                "Requested amount in transfer exceeds the current available balance of the wallet contract."
            );
        }
        _;
    }
    modifier m_checkDailyLimits(uint requestedAmount, OperationType operation) {
        if (OperationType.TRANSFER == operation  && 0 != dailyLimits.dailyLimit) {
            if (now / 1 days == dailyLimits.relatedDay) { // there are some previous transfers within the current day
                require(requestedAmount + dailyLimits.dailyAlreadySpent <= dailyLimits.dailyLimit , "Daily limit is exceeded.");
            } else{ //there are no previous transfers within the current day
                require(requestedAmount  <= dailyLimits.dailyLimit , "Daily limit is exceeded.");
            }
        }
        _;
    }
    modifier m_checkLastResortElapsedTime() {
        if (0 != lastResort.timeoutDays) {
            require(now / 1 days >= lastResort.lastActiveDay + lastResort.timeoutDays, "Not enought time has elapsed since the last confirmed operation.");
            _;  // Body of function can be run only when timeout != 0
        }
    }
    modifier m_checkConfirmMaterialLength(bytes16[] memory confirmMaterial) {
        require(confirmMaterial.length == MT_child_height - MT_child_depthOfCachedLayer + 1, "Confirmation material has wrong length.");
        _;
    }
    modifier m_checkNotLastParentTreeOperation(){
        require(pendingOpers.length < MT_parent_numberOfOTPs - 1, // the last OTP is reserved for a new parent root hash
            "Last parent tree operation can be used only for introducing a new parent tree."
        );
        _;
    }
    modifier m_checkLastParentTreeOperation(){
        require(pendingOpers.length == MT_parent_numberOfOTPs - 1,
            "Introducing a new parent root hash can only be done as the last operation."
        );
        _;
    }
    modifier m_checkNotDepletedChildTreeOperations(){
        require(pendingOpers.length  < MT_child_numberOfOTPs * (MT_parent_currentChildTreeIdx + 1) - 1,
            "Child tree operations are depleted => new child tree needs to be adjusted using the last child tree OTP."
        );
        _;
    }
    modifier m_checkDepletedChildTreeOperations() {
        require(pendingOpers.length == MT_child_numberOfOTPs * (MT_parent_currentChildTreeIdx + 1) - 1,
            "Child tree operations must be depleted, except the last one, before establishing a new child tree."
        );
        _;
    }
    modifier m_checkBoundariesOfChildTree(uint32 otpID){
        require(otpID >= MT_parent_currentChildTreeIdx * MT_child_numberOfOTPs
               && otpID < (MT_parent_currentChildTreeIdx + 1) * MT_child_numberOfOTPs,
                "Requested OTP ID is out of boundaries for the current child tree."
        );
        _;
    }

    ///////////// Transaction-Based Public Methods ////////////////

    /* Fallback function that receives Ether sent on the contract's address. */
    function() external payable { }

    /**
     * Stores root hash and cached layer of authenticator's Merkle Tree
     * PRE  validators: height of the tree ; length of cached layer
     * POST validators: consistency / derivation of the root hash.
     */
    constructor(bytes16 parent_rootHash, uint8 parent_height,
                uint8 child_heightOfMT, uint8 child_depthOfCachedLayer, bytes16[] memory child_cachedLayerOfMT,
                bytes16[] memory authPath_childTree, bytes20 sides_childTree, // authPath enables to verify integrity of child root hash (in authPath_childTree[0])
                uint16 _hashChainLen,
                uint _dailyLimit, address payable _lastResortAddr, uint64 _maxInactiveDays)
    public
        m_checkMaxMinHeight(child_heightOfMT)
        m_checkLengthOfCachedLayer(child_heightOfMT, child_depthOfCachedLayer, child_cachedLayerOfMT)
    {
        // require(parent_height - child_heightOfMT <= MAX_LEN_OF_PROOF, "Maximum height of parent tree minus height of child tree is exceeded.");
        owner = tx.origin; // considering this method to be called from contract factory created beforehand (user should check the correct value after deploy)
        MT_hash_chain_len = _hashChainLen;
        MT_parent_rootHash = parent_rootHash;
        MT_parent_height = parent_height;
        MT_parent_numberOfOTPs = (uint32(2) ** parent_height) * _hashChainLen;

        MT_child_rootHash = authPath_childTree[0];
        MT_child_height = child_heightOfMT;
        MT_child_numberOfOTPs = (uint32(2) ** child_heightOfMT) * _hashChainLen;
        MT_child_depthOfCachedLayer = child_depthOfCachedLayer;
        for (uint32 i = 0; i < child_cachedLayerOfMT.length; i++) { // copy from calldata to storage
            MT_child_cachedLayer.push(child_cachedLayerOfMT[i]);
        }
        lastResort.addr = _lastResortAddr;
        lastResort.lastActiveDay = uint64(now / 1 days);
        lastResort.timeoutDays = _maxInactiveDays;
        dailyLimits.relatedDay = uint64(now / 1 days);
        dailyLimits.dailyLimit = _dailyLimit;
        _postCheckChildTreeConsistency(authPath_childTree, sides_childTree, 0);
    }

    /**
     * This is the initialization part of the operation. If the type is TRANSFER, no balance checking is made here, but postponed to the confirmation part.
     * NOTE: We opted for generalization of operations into two shared steps for all operations (init and confirm), which can save additional storage and
     *       code logic required for coping with race conditions.
     */
    function initNewOper(address payable _addr, uint _param, OperationType _operation) public
        m_checkOnlyOwner()
        m_checkNotLastParentTreeOperation() // order of precedence is important (check on child tree depletion must be done afterwards)
        m_checkNotDepletedChildTreeOperations()
    {
        _enqueueNewPendingOperation(_addr, _param, true, _operation);
        emit InitOperEvent("Operation was initiated.", _addr, uint32(pendingOpers.length - 1), _param, _operation);
    }

    /**
     * This is the confirmation part of the operation. Checking of enough balance and daily limits are made here if the operation is TRANSFER.
     * The 'confirmMaterials' represnets secret OTP + all hashes of compact proof up to the node in cached layer.
     * The 'sides' distinguishes whether a particular item in 'confirmMaterials' is the left or right one.
     * The max size of sides is equal to MAX_LEN_OF_PROOF.
     */
    function confirmOper(bytes16[] memory confirmMaterial, bytes20 sides, uint32 otpID) public
        // m_checkOnlyOwner() // optional
        m_checkEnoughBallance(pendingOpers[otpID].param, pendingOpers[otpID].operation)
        m_checkDailyLimits(pendingOpers[otpID].param, pendingOpers[otpID].operation) // early check to save gas for 2FA verification if daily limits are exceeded
    {

        _checkProofOf2FA(otpID, confirmMaterial, sides); // After this point is 2FA successful.
        _executeOperation(pendingOpers[otpID]);
        pendingOpers[otpID].pending = false; // set just pending status to save 6K gas in contrast to 'delete pendingOpers[otpID]'
    }

    /**
     * This method introduces a new child tree and can be executed by owner only when child OTPs are depleted.
     * Although consistency of the new child tree is verified against parent root hash a 2FA would not be needed here,
     * we use 2FA here to avoid desynchronization of authenticator device.
     * 2FA is peformed in a single step, which enables in the worst case an attacker to submit inefficient layer of child Merkle tree,
     * making a cost of follow-up transactions non-optimal.
     */
    function adjustNewChildTree(uint8 newDepthOfCachedLayer, bytes16[] memory newCachedLayerOfMT,
        bytes16[] memory authPath_childTree, bytes20 sides_childTree,
        bytes16[] memory confirmMaterial, bytes20 sides
    ) public
        m_checkOnlyOwner() // this is optional, but it enables to minimize attack surface of an attacker "deoptimizing a cost of further transactions"
        m_checkNotLastParentTreeOperation() // order of precedence is important (check on child tree depletion must be done afterwards)
        m_checkDepletedChildTreeOperations()
        m_checkLengthOfCachedLayer(MT_child_height, newDepthOfCachedLayer, newCachedLayerOfMT)
    {
        _checkProofOf2FA(uint32(pendingOpers.length), confirmMaterial, sides); // after this point is 2FA successful

        // add nop operation into pendingOperations aray to preserve indices == OTP IDs
        _enqueueNewPendingOperation(address(0), 0, false, OperationType.NOP);

        assert(newDepthOfCachedLayer == MT_child_depthOfCachedLayer); // TBD: later remove and resolve reallocation when needed
        for (uint32 i = 0; i < newCachedLayerOfMT.length; i++) { // store new cached layer
            MT_child_cachedLayer[i] = newCachedLayerOfMT[i];
        }
        // MT_child_depthOfCachedLayer = newDepthOfCachedLayer; // TBD
        MT_child_rootHash = authPath_childTree[0];
        MT_parent_currentChildTreeIdx++;
        _postCheckChildTreeConsistency(authPath_childTree, sides_childTree, MT_parent_currentChildTreeIdx);
    }

    /**
     * This appendes h(candidate on a new parent root hash || last OTP) to the 1st stage buffer
     */
    function adjustNewParentTree_stage1(bytes16 hashOfRootAndOTP) public
        m_checkOnlyOwner()
        m_checkLastParentTreeOperation()
    {
        NewParentTree_1stStageBuffer.push(hashOfRootAndOTP);
    }

    /**
     * This apends candidate on a new parent root hash to the 1st stage buffer
     */
    function adjustNewParentTree_stage2(bytes16 newRootHash) public
        m_checkOnlyOwner()
        m_checkLastParentTreeOperation()
    {
        NewParentTree_2ndStageBuffer.push(newRootHash);
    }

    /**
     * The method verifies OTP against the first macthing entry in 2nd stage buffer and 1st stage buffer.
     * If matched, then the current parent root hash is changed to matched entry and other additional data related to child root hash are updated as well.
     * The number of OTPs (i.e., ~parent height) cannot be changed.
     */
    function adjustNewParentTree_stage3(bytes16[] memory confirmMaterial, bytes20 sides,
        uint8 child_depthOfCachedLayer, bytes16[] memory child_cachedLayerOfMT, bytes16[] memory authPath_childTree, bytes20 sides_childTree
    ) public
        m_checkOnlyOwner()
        m_checkLastParentTreeOperation()
    {
        bytes16 otp = confirmMaterial[0];
        _checkProofOf2FA(MT_parent_numberOfOTPs - 1, confirmMaterial, sides); // After this point is 2FA successful.

        for (uint64 i = 0; i < NewParentTree_2ndStageBuffer.length; i++) {
            for (uint64 j = 0; j < NewParentTree_1stStageBuffer.length; j++) {


                // find a candidate on a new root hash submitted by a user
                if(bytes16(keccak256(abi.encodePacked(NewParentTree_2ndStageBuffer[i], otp))) == NewParentTree_1stStageBuffer[j]){
                    _resetAllDataRespectingNewParentTree(NewParentTree_2ndStageBuffer[i], child_depthOfCachedLayer,
                        child_cachedLayerOfMT, authPath_childTree, sides_childTree
                    );
                    NewParentTree_1stStageBuffer.length = 0;
                    NewParentTree_2ndStageBuffer.length = 0;
                    return;
                }
            }
        }
    }

    /**
     * If the condition for elapsed time since the last operation is met, then funds are tranferred to the last resort address.
     * Anyone can call this method.
     */
    function sendFundsToLastResortAddress() public
        m_checkLastResortElapsedTime() // nothing happen when last resort timeout is 0
    {
        selfdestruct(lastResort.addr);
    }

    function getCurrentOtpID() view public returns (uint32) {
        return uint32(pendingOpers.length);
    }

    function getSizeOfNPT_stage1Buf() view public returns (uint) {
        return NewParentTree_1stStageBuffer.length;
    }

    function getSizeOfNPT_stage2Buf() view public returns (uint) {
        return NewParentTree_2ndStageBuffer.length;
    }

    // function computeNstepsOfHashChain(uint16 N) public {
    //     bytes16 h = 1;
    //     for (uint16 i = 0; i < N; i++) {
    //         h = bytes16(keccak256(h));
    //     }
    //     emit DebugEvent6("computed hash chain", bytes32(h));
    // }

    // function computeNstepsOfHashChainAndConcat(uint16 N) public {
    //     bytes16 h = 1;
    //     bytes16 toConcat = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
    //     for (uint16 i = 0; i < N; i++) {
    //         h = bytes16(keccak256(abi.encodePacked(h, toConcat)));
    //     }
    //     emit DebugEvent6("computed hash chain", bytes32(h));
    // }

    ///////////// Transaction-Based Private Methods (modifying the state) ////////////////

    function _postCheckChildTreeConsistency(bytes16[] memory authPath, bytes20 sides, uint32 newChildTreeIdx) private view {
        // check consistency of cached layer against child root hash
        require(_isCachedLayerConsistent(), "Cached layer of child Merkle tree is not consistent.");

        // check consistency of child root hash against parent root hash
        require(_deriveChildTreeIdx(sides) == newChildTreeIdx, "Provided child tree index does not correspond to the expected one.");
        assert(authPath[0] == MT_child_rootHash);
        bytes16 providedAnswer = _reduceAuthPath(authPath, sides);
        require(providedAnswer == MT_parent_rootHash, "Child root hash is not consistent with the parent root hash.");
    }

    function _checkProofOf2FA(uint32 otpID, bytes16[] memory confirmMaterial, bytes20 sides) internal
        m_checkBoundariesOfChildTree(otpID)
        m_checkConfirmMaterialLength(confirmMaterial)
    {
        uint32 childOTPOffset = (otpID - MT_parent_currentChildTreeIdx * MT_child_numberOfOTPs); // offset in a current subtree
        uint32 childLeafID = childOTPOffset % (MT_child_numberOfOTPs / MT_hash_chain_len); // ~Beta
        uint32 expectedIdx =_getExpectedChildIdxAgainstCachedLayer(childLeafID);

        // emit DebugEvent7("Indices of child:", expectedIdx, _deriveChildIdxAgainstCachedLayer(sides));
        require(_deriveChildIdxAgainstCachedLayer(sides) == expectedIdx, "Attempt to confirm by confirmation material with wrong ID.");

        // check whether cm is authenticated against node in a cache
        uint32 childHashchainCnt =  (childOTPOffset / (MT_child_numberOfOTPs / MT_hash_chain_len)); // ~(P - alpha + 1)
        emit DebugEvent8("Hash chain count:", childHashchainCnt);
        _checkNotInvalidatedIterationLayer(childHashchainCnt);
        bytes16 providedAnswer = _reduceConfirmMaterial(confirmMaterial, sides, childHashchainCnt);
        uint32 rootIdxInCachedLayer = childLeafID / (uint32(2) ** (MT_child_height - MT_child_depthOfCachedLayer));
        // emit DebugEvent5("Comparison of provided OTP and expected", providedAnswer, MT_child_cachedLayer[rootIdxInCachedLayer]);
        require(providedAnswer == MT_child_cachedLayer[rootIdxInCachedLayer], "OTP-based authentication unsuccessfull.");
    }

    function _enqueueNewPendingOperation(address payable addr, uint param, bool isPending, OperationType operation) internal {
        RequestedOperation memory newOper = RequestedOperation(addr, param, isPending, operation);
        pendingOpers.push(newOper);
    }

    /**
     * Compare iteration layer of requested OTP with the iteration layer of the top of pending operation list
     */
    function _checkNotInvalidatedIterationLayer(uint32 hashChainCntOTP) internal view {
        uint32 offsetOfTOPinChildTree = (uint32(pendingOpers.length - 1) - MT_parent_currentChildTreeIdx * MT_child_numberOfOTPs); // offset in a current subtree
        uint32 hashChainCntTOP = (offsetOfTOPinChildTree / (MT_child_numberOfOTPs / MT_hash_chain_len));
        require(hashChainCntTOP == hashChainCntOTP, "Requested OTP ID lays in already invalidated iteration layer of a subtree.");
    }

    function _executeOperation(RequestedOperation storage requestedOper) internal {
        if (OperationType.TRANSFER == requestedOper.operation) {
            requestedOper.addr.transfer(requestedOper.param);
            _updateDailyExpenses(requestedOper.param);
            emit TransferEvent("Transfer confirmed by 2FA.", requestedOper.addr, requestedOper.param);
        } else if (OperationType.SET_DAILY_LIMIT == requestedOper.operation) {
            dailyLimits.dailyLimit = requestedOper.param;
            emit DailyLimitChangedEvent("Daily limit changed.", requestedOper.param);
        } else if (OperationType.SET_LAST_RESORT_TIMEOUT == requestedOper.operation) {
            lastResort.timeoutDays = uint64(requestedOper.param);
            emit LastResortTimeoutEvent("Last resort timeout adjusted.", uint64(requestedOper.param));
        } else if (OperationType.SET_LAST_RESORT_ADDRESS == requestedOper.operation) {
            lastResort.addr = requestedOper.addr;
            emit LastResortAddrEvent("Last resort address adjusted.", requestedOper.addr);
        } else if(OperationType.DESTRUCT_WALLET == requestedOper.operation) {
            selfdestruct(requestedOper.addr);
        } else {
            // This should not happen if client works properly. Client should always check operation type and info after the INIT.
            revert("Unknown type of requested operation.");
        }
        // This has to be done after 2FA, as an attacker saboteur may refresh the activity and delay a user in receiveing funds on last resort address.
        lastResort.lastActiveDay = uint64(now / 1 days);
    }

    /**
     * This method is called when new parent tree is bootstrapped. The number of OTPS cannot be changed, only height of child tree,
     * including its depth of cached layer.
     */
    function _resetAllDataRespectingNewParentTree(bytes16 newParentRootHash, uint8 child_depthOfCachedLayer,
        bytes16[] memory child_cachedLayerOfMT, bytes16[] memory authPath_childTree, bytes20 sides_childTree
    ) internal
        m_checkLengthOfCachedLayer(MT_child_height, child_depthOfCachedLayer, child_cachedLayerOfMT)
    {
        MT_parent_rootHash = newParentRootHash; // update a new parent root hash
        MT_parent_currentChildTreeIdx = 0;
        MT_parent_currentParentTreeIdx += 1;

        MT_child_rootHash = authPath_childTree[0];
        MT_child_depthOfCachedLayer = child_depthOfCachedLayer;
        assert(child_depthOfCachedLayer == MT_child_depthOfCachedLayer); // TBD: later remove and resolve reallocation when needed
        for (uint32 i = 0; i < child_cachedLayerOfMT.length; i++) { // copy from calldata to storage
            MT_child_cachedLayer[i] = child_cachedLayerOfMT[i];
        }
        delete pendingOpers;
        assert(0 == pendingOpers.length);
        _postCheckChildTreeConsistency(authPath_childTree, sides_childTree, 0);
    }

    function _updateDailyExpenses(uint amount) internal {
        // No checks are made here, as they've been already done in PRE validators.
        if (0 != dailyLimits.dailyLimit) {
            if (now / 1 days == dailyLimits.relatedDay) {
                dailyLimits.dailyAlreadySpent += amount;   // there are some previous Opers within the same day
            } else{
                dailyLimits.dailyAlreadySpent = amount; // there are no previous Opers in the current day
                dailyLimits.relatedDay = uint64(now / 1 days); // update a current day
            }
        }
    }

    ///////////// Call-Based Private Methods (not modifying the state) ////////////////

    function _isCachedLayerConsistent() private view returns (bool) {
        return (_reduceMT(MT_child_cachedLayer, uint32(MT_child_cachedLayer.length)) == MT_child_rootHash) ? true : false;
    }

    function _reduceMT(bytes16[] memory layer, uint32 length) private pure returns (bytes16) {
        if (1 == length) return layer[0];

        for (uint32 i = 0; i <= (length / 2) - 1; i++) {
            layer[i] = bytes16(keccak256(abi.encodePacked(layer[2 * i], layer[2 * i + 1])));
        }
        return  _reduceMT(layer, length / 2);
    }

    /**
     * Based on the depth of cached layer, the 'MT_child_depthOfCachedLayer' of most significant bits in childLeadIF are set to zero.
     * The resulting value has index that addresses position of childLeafID against a corresponding node in the cached layer.
     * Corresponding node stands for the one on the path from leaf to the child root.
     */
    function _getExpectedChildIdxAgainstCachedLayer(uint32 childLeafID) private view returns (uint32){
        uint32 mask = 0xFFFFFFFF;
        uint32 retId = childLeafID;
        for (uint8 i = MT_child_height - MT_child_depthOfCachedLayer ; i < MT_child_height ; i++){
            uint32 bitToClear = uint32(0x01) << i;
            retId &= mask ^ bitToClear;
        }
        return retId;
    }

    /**
     * Based on the information about left/right sides of items in confirmation material, the function determines the index of the leaf node
     * that is associated with the passed confirmation material against corresponding node in the cached layer. Corresponding node stands
     * for the one on the path from the leaf node to the root.
     */
    function _deriveChildIdxAgainstCachedLayer(bytes20 sides) private view returns (uint32) {
        uint32 derivedIdx = 0;
        // derive OTPID from bottom to cached layer
        for(uint8 i = 0 ; i < MT_child_height - MT_child_depthOfCachedLayer ; i++){
            if(byte(0x01) == sides[i]){
                derivedIdx |=  uint32(0x01) << i;
            }
        }
        return derivedIdx;
    }

    function _deriveChildTreeIdx(bytes20 sides) private view returns (uint32) {
        uint32 derivedIdx = 0;
        // derive child tree Idx from the level of child root to the the parent root
        for(uint8 i = 0 ; i < MT_parent_height - MT_child_height ; i++){
            if(byte(0x01) == sides[i]){
                derivedIdx |=  uint32(0x01) << i;
            }
        }
        return derivedIdx;
    }

    /**
     * The function first resolve hashchain in order to get leaf node of the child tree and then reduces passed
     * confirmation material in 'confirmMaterial' and auxiliary information about left/ritgh side of items in it.
     * The pairs of items in confirmation material are joined by a concatenation.
     */
    function _reduceConfirmMaterial(bytes16[] memory confirmMaterial, bytes20 sides, uint32 hchainCnt) internal view returns (bytes16) {
        uint32 alpha = MT_hash_chain_len - hchainCnt - 1;
        for (uint32 i = 0; i < hchainCnt; i++) {
            confirmMaterial[0] = bytes16(keccak256(abi.encodePacked(alpha + i + 1, confirmMaterial[0]))); // Resolve hash chain to get OTP
        }
        //  and then compute h(OTP) to get the leaf of the tree
        confirmMaterial[0] = bytes16(keccak256(abi.encodePacked(confirmMaterial[0])));
        return _reduceAuthPath(confirmMaterial, sides);
    }

    function _reduceAuthPath(bytes16[] memory authPath, bytes20 sides) internal pure returns (bytes16){
        for (uint8 i = 1; i < authPath.length ; i++) {
            if(byte(0x00) == sides[i - 1]){
                authPath[0] = bytes16(keccak256(abi.encodePacked(authPath[0], authPath[i])));
            } else{
                authPath[0] = bytes16(keccak256(abi.encodePacked(authPath[i], authPath[0])));
            }
        }
        return authPath[0];
    }

    function _concatB32(bytes16 bytes_a, bytes16 bytes_b) private pure returns (bytes32 bytes_c){
        bytes_c = bytes32(bytes_a) | (bytes32(bytes_b) >> (16 * 8));
    }
}
