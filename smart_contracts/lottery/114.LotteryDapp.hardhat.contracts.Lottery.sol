// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

// How the winner is going to get generated
// VRF = Verifiable random function 
// using VRFConsumerBase contract to call the requestRandomness function from that contract 
// VRF Consumer base contract will then call VRFCoordinator contract
// VRFCoordinator will call the fullFillRandomness function which selects the winner.


contract Lottery is VRFConsumerBase, Ownable {

    // Chainlink variables
    // Total amount of LINK to send with the request

    uint256 public fee;
    // ID of public key against which the random is generated
    bytes32 public keyHash;

    // Address of the player
    address[] public players;

    // Max number of players in one game
    uint8 maxPlayers;

    // Check if game is started or not consider it as a flag 
    bool public gameStarted;

    // Entry fees for joining the game
    uint256 entryFee;

    // Current game id
    uint256 public gameId;


    // Creating Events
    // Event to call while starting game 
    event GameStarting(uint256 gameId, uint8 maxPlayers, uint256 entryFee);
    // Event to call when someone join the game
    event PlayerJoined(uint256 gameId, address player);
    // Event to call when game ends
    event EndGame(uint256 gameId, address winner, bytes32 requestId);


    // Declaring constructor 
    // It inherits a VRFCoordinatorbase and Initiate the value for keyhash, fees and gameStarting
    // vrf coordinator => It is an address of VRFcoordinator contract
    // linkToken => It is an address of LINK token contract
    // vrfFee => The amount of LINK to send with the request
    // vrfKeyHash => It is an id of public key against which randomness is generated

    constructor(address vrfCoordinator, address linkToken, bytes32 vrfkeyHash, uint256 vrfFee) VRFConsumerBase(vrfCoordinator, linkToken) {
        keyHash = vrfkeyHash;
        fee = vrfFee;
        gameStarted = false;
    }

    // function for starting game with appropriate values
    function startGame(uint8 _maxPlayers, uint256 _entryFee) public onlyOwner {
        // Checking if the game is already running or not
        require(!gameStarted, "Game is already running.");
        // Emptying the players array
        delete players;
        // Setting the max players for this game
        maxPlayers = _maxPlayers;
        // Setting the game started flag to true
        gameStarted = true;
        // Setup the entryFee for the game 
        entryFee = _entryFee;
        gameId += 1;
        emit GameStarting(gameId, maxPlayers, entryFee);
    }

    // Function to join the game
    function joinGame() public payable {
        // Check if a game is already running
        require(gameStarted,"Game is not started yet");
        // Check if the value sent by the user matches the entryFee
        require(msg.value == entryFee, "Value is not equal to entry Fees.");
        // Checking the game has space for player or is it full
        require(players.length < maxPlayers, "Game is already full.");
        // If there is space then add player
        players.push(msg.sender);
        emit PlayerJoined(gameId, msg.sender);
        // IF the list is full start winner selection for the game
        if (players.length == maxPlayers) {
            getRandomWinner();
        }
    }

    // fulfillRandomness is called by VRFCoordinator when it receives valid VRF proof
    // this is an override function to act upon number when random get generated by chainlink vrf
    // requestId =>This is unique for the request we sent to vrf coordinator
    // randomness => This is a random number generated and returned to us by vrf coordinator

    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual override {
     // We want out winnerIndex to be in the length from 0 to players.
      // For this we will mod it with the player.length value
      uint256 winnerIndex = randomness % players.length;
      // Now we will get the winner address from the players array
      address winner = players[winnerIndex];
      // Sending the ether in the contract to the winner
      (bool sent,) = winner.call{value: address(this).balance}("");
      require(sent,"Failed to send Ether");
      // Emit that the game has ended as we have declared the winner.
      emit EndGame(gameId, winner, requestId);
      // Set the gameStarted variable to false
      gameStarted = false;
    }


// Generating random winner using this function
function getRandomWinner() private returns (bytes32 requestId) {
    // LINK is an internal interface for link token found within the vrf consumerbase
    // Here we use the balanceOF method to check the balance of the link that our contract has enough link to share so we can request the vrf coordinator for randomness
    require(LINK.balanceOf(address(this)) >= fee, "Not Enough LINK's");
    //  Make a request to VRFcoordinator
    // Request randomness is a function within the VRF consumer base
    // It starts with the process of randomness generation
    return requestRandomness(keyHash, fee);
}

    // Function to receive ether, msg.data must be empty
    receive() external payable {}

    // Fallback function is called when msg.data is not empty
    fallback() external payable {}
} 