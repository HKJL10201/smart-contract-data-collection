pragma solidity ^0.4.18;

/** @title Lottery */
contract Lottery {
  //----------Structs------------
  struct SenderHash {
    bytes32 hash;
    address sender;
  }

  //----------Variables------------

  // Ticket to SenderHash
  mapping (uint => SenderHash) consumerHashes;
  //Ticket to Address
  mapping (uint => address) playerTickets;
  //Address to amount
  mapping (address => uint) winnersMap;
  //User to balance
  mapping (address => uint) userBalances;

  //Bought tickets
  uint[] consumedTickets;
  //Verified tickets
  uint[] playableTickets;
  //Winner addresses
  address[] winners;
  //Selected tickets
  uint[23] winnerTickets;
  //Winners of last lottery
  uint[23] lastWinnerTickets;
  //Random numbers from users
  uint[] randomNumbers;
  //Collected money in single run

  uint collectedMoney;
  //Distributed money in single run
  uint distributedMoney;
  //Charity address
  address public charityAddress;
  uint charityBalance;
  // When the lottery started
  uint public lotteryStart;

  //---------Constants---------------
  // Durations for lottery stages in days
  uint public constant PURCHASE_DURATION = 5 days;
  uint public constant REVEAL_DURATION = 2 days;

  uint constant TICKET_START = 0;
  uint constant TICKET_END = 99999;

  //Prize constants in ether
  uint[] PRIZES = [50000 ether, 10000 ether, 400 ether, 400 ether,
  200 ether , 200 ether, 200 ether, 200 ether, 200 ether,
  200 ether, 200 ether, 200 ether, 200 ether, 200 ether, 200 ether,
  100 ether, 100 ether, 100 ether, 100 ether, 100 ether];

  uint constant FOUR_DIGIT_WINNER_PRIZE = 40 ether;
  uint constant THREE_DIGIT_WINNER_PRIZE = 10 ether;
  uint constant TWO_DIGIT_WINNER_PRIZE = 4 ether;

  uint constant TICKET_COST = 2 ether;

  //---------Modifiers---------------
  // Checks if lotter is still in purchase period
  modifier purchaseOngoing() {
    require(now < lotteryStart + PURCHASE_DURATION);
    _;
  }

  // Checks if winner reveal period is ongoing
  modifier revealOngoing() {
    uint end = lotteryStart + PURCHASE_DURATION + REVEAL_DURATION;
    require(now < end && now > lotteryStart + PURCHASE_DURATION);
    _;
  }
  //---------Functions----------------

  //Create the lottery
  function Lottery(address _charityAddress) {
    charityAddress = _charityAddress;
    resetLottery(false);
  }

  // Fallback function
  function () {
    revert();
  }

  // After winners have been declared and awarded, clear the arrays and reset the balances
  function resetLottery(bool refunded) private {
    lotteryStart = now;
    for(uint i = 0; i < playableTickets.length; i++){
      delete playerTickets[playableTickets[i]];
    }
    for(uint k = 0; k < consumedTickets.length; k++){
      delete consumerHashes[consumedTickets[k]];
    }
    for(uint j = 0; j < winners.length; j++){
      delete winnersMap[winners[j]];
    }

    delete consumedTickets;
    consumedTickets.length = 0;
    delete randomNumbers;
    randomNumbers.length = 0;
    delete winners;
    winners.length = 0;
    if(!refunded){
        lastWinnerTickets = winnerTickets;
    }
    else{
        delete lastWinnerTickets;
    }
    delete winnerTickets;
    delete playableTickets;
    playableTickets.length = 0;
    collectedMoney=0;
    distributedMoney=0;
  }

  /** @dev Checks if requested ticket is available.
    * @param ticketNumber Selected ticket number to control.
    * @return true if ticket is not bought before.
    */
  function ticketAvailable(uint ticketNumber) public view returns (bool) {
    return ticketNumber >= TICKET_START && ticketNumber <= TICKET_END && consumerHashes[ticketNumber].hash == 0;
  }

  /** @dev Issues a ticket and provided hash to the message sender.
    * @param playerHash Hash generated by player. Contract expects playerHash == keccak256(randomNumber, ticketNumber, msg.sender)
    * @param ticketNumber Selected ticket number.
    * @return Requested ticket number.
    */
  function buyTicket(bytes32 playerHash, uint ticketNumber) external payable purchaseOngoing returns (uint) {
    require(msg.value == TICKET_COST);
    require(playerHash != 0);
    require(ticketAvailable(ticketNumber));
    consumedTickets.push(ticketNumber);
    consumerHashes[ticketNumber] = SenderHash(playerHash, msg.sender);
    collectedMoney += TICKET_COST;
    return ticketNumber;
  }

  /** @dev Checks if sender has sent a valid random number to join the actual lottery
    * @param randomNumber A number selected by user, which was previously sent within the playerHash.
    * @param ticketNumber Selected ticket number.
    * @return true/false.
    */
  function enterLottery(uint randomNumber, uint ticketNumber) external revealOngoing returns (bool) {
    SenderHash storage sh = consumerHashes[ticketNumber];
    require(sh.sender == msg.sender && keccak256(randomNumber, ticketNumber, msg.sender) == sh.hash);
    require(playerTickets[ticketNumber] == 0);
    playerTickets[ticketNumber] = msg.sender;
    playableTickets.push(ticketNumber);
    randomNumbers.push(randomNumber);
    return true;
  }

  /** @dev Generates winner and distributes or refunds the money.
    * @return true if awards are distributed, otherwise false if money is refunded.
    */
  function generateWinners() private returns (bool) {
    generateFiveDigitWinners();
    generateFourDigitWinners();
    generateThreeDigitWinners();
    generateTwoDigitWinners();
    if (checkEnoughMoneyCollected()){
      distributeAwards();
      sendRemainingToCharity();
      resetLottery(false);
      return true;
    }
    else {
      refundCollectedMoney();
      return false;
    }
  }

  /** @dev Shows generated winning ticket numbers.
    * @return winner tickets array.
    */
  function getWinnerTickets() external view returns (uint[23]){
    return lastWinnerTickets;
  }

  /** @dev Sends available balance to msg.sender.
    * @return returns transferred amount.
    */
  function withdrawLotteryMoney() external returns (uint){
    if(isLotteryEnded()){
      generateWinners();
    }
    uint prize = userBalances[msg.sender];
    if (prize > 0){
      userBalances[msg.sender] = 0;
      msg.sender.transfer(prize);
    }
    return prize;
  }

  /** @dev Checks if enough money collected before distribution.
    * @return true if enoug money is collected, otherwise false.
    */
  function checkEnoughMoneyCollected() private view returns (bool) {
    return collectedMoney >= distributedMoney;
  }
  /** @dev Refunds ticket money to all ticket holders.
    */
  function refundCollectedMoney() private {
    for(uint i = 0; i < consumedTickets.length; i++){
      uint ticket = consumedTickets[i];
      address consumerAddress = consumerHashes[ticket].sender;
      userBalances[consumerAddress] += TICKET_COST;
    }
    resetLottery(true);
  }

  /** @dev Send remaining money to the charityAddress
    * @return true if transfer is successfull.
    */
  function sendRemainingToCharity() private returns (bool){
    uint remaining = collectedMoney - distributedMoney;
    charityBalance += remaining;
    return true;
  }

  function charityWithdraw() public returns (bool){
    require(msg.sender == charityAddress);
    require(charityBalance > 0);
    msg.sender.transfer(charityBalance);
  }

  /** @dev Generates five digit winner tickets and checks if there is any player wins it.
    */
  function generateFiveDigitWinners() private {
    for(uint i = 0; i < PRIZES.length; i++){
      uint winnerTicket = randomTicket(i);
      winnerTickets[i] = winnerTicket;
      address winnerAddress = playerTickets[winnerTicket];
      if(winnerAddress != 0x0){
        awardWinner(winnerAddress, PRIZES[i]);
      }
    }
  }

  /** @dev Generates four digit winner tickets and checks if there is any player wins it.
    */
  function generateFourDigitWinners() private{
    uint winnerTicket = randomTicket(FOUR_DIGIT_WINNER_PRIZE);
    uint fourDigitWinner = winnerTicket % 10000;
    winnerTickets[20] = fourDigitWinner;
    for(uint i = 0; i < playableTickets.length; i++){
      uint currentTicket = playableTickets[i];
      address winnerAddress = playerTickets[currentTicket];
      if(currentTicket % 10000  == fourDigitWinner && winnerAddress != 0){
        awardWinner(winnerAddress, FOUR_DIGIT_WINNER_PRIZE);
      }
    }
  }

  function generateThreeDigitWinners() private{
    uint winnerTicket = randomTicket(THREE_DIGIT_WINNER_PRIZE);
    uint threeDigitWinner = winnerTicket % 1000;
    winnerTickets[21] = threeDigitWinner;
    for(uint i = 0; i < playableTickets.length; i++){
      uint currentTicket = playableTickets[i];
      address winnerAddress = playerTickets[currentTicket];
      if(currentTicket % 1000  == threeDigitWinner && winnerAddress != 0){
        awardWinner(winnerAddress, THREE_DIGIT_WINNER_PRIZE);
      }
    }
  }

  /** @dev Generates two digit winner tickets and checks if there is any player wins it.
    */
  function generateTwoDigitWinners() private{
    uint winnerTicket = randomTicket(TWO_DIGIT_WINNER_PRIZE);
    uint twoDigitWinner = winnerTicket % 100;
    winnerTickets[22] = twoDigitWinner;
    for(uint i = 0; i < playableTickets.length; i++){
      uint currentTicket = playableTickets[i];
      address winnerAddress = playerTickets[currentTicket];
      if(currentTicket % 100  == twoDigitWinner && winnerAddress != 0x0){
        awardWinner(winnerAddress, TWO_DIGIT_WINNER_PRIZE);
      }
    }
  }

  /** @dev Temporarily awards the user for per lottery run.
      @param winnerAddress address to be awarded
      @param amount reward amount
    */
  function awardWinner(address winnerAddress, uint amount) private {
    winnersMap[winnerAddress] += amount;
    winners.push(winnerAddress);
    distributedMoney += amount;
  }

  /** @dev Distributes the temporary awards to actual user balances.
    */
  function distributeAwards() private {
    for(uint i = 0; i < winners.length; i++){
      address winnerAddress = winners[i];
      userBalances[winnerAddress] += winnersMap[winnerAddress];
    }
  }

  /** @dev Returns a random ticket number in range.
      @param seed a dynamic seed to generate different random tickets per request.
    */
  function randomTicket(uint seed) private view returns (uint){
    return (random(seed) % (TICKET_END - TICKET_START + 1)) + TICKET_START;
  }

  /** @dev Generates a hash with concatenating randomNumbers issued by users, valid tickets and a seed
      @param seed a dynamic seed to generate different random tickets per request.
    */
  function random(uint seed) private view returns (uint) {
    return uint(keccak256(randomNumbers, playableTickets, seed));
  }

  function isLotteryEnded() private view returns (bool){
    return now > lotteryStart + PURCHASE_DURATION + REVEAL_DURATION;
  }
}
