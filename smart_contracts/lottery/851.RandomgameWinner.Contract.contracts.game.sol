//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;


import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

contract RandomGame is VRFConsumerBase, Ownable { 

    //Chainlink vars 
    uint256 public fee;
    //ID of public key against which randomness is generated 
    bytes32 public keyhash; 


    //address of players 
    address[]  public players; 
    //Max number of players in one game 
    uint8 maxPlayers; 
    //Var to indicate if the game has started or not 
    bool public gameStarted; 
    //The fees for entering the game 
    uint256 entryFee;
    //current Game ID
    uint256 gameID; 


    //emit when game is started 
    event GameStarted(uint256 gameID, uint8 maxPlayers, uint256 entryFee);
    //emit when someone joins the game 
    event PlayerJoined(uint256 gameID, address player); 
    //emit when the game ends 
    event GameEnded(uint256 gameID, address winner, bytes32 requestId);



  //vrfCoordinator address of VRFCoordinator contract
  //linkToken address of LinkToken
  //vrFee the amount of LINK to send with the request 
  //vrfKeyHash ID of public key against which randomness is generated   
  constructor(address vrfCoordinator, address linkToken,bytes32 vrfKeyHash, uint256 vrfFee)
    VRFConsumerBase(vrfCoordinator, linkToken) {
        keyhash = vrfKeyHash;
        fee = vrfFee;
        gameStarted = false;
    }

    //start game 
    function startGame(uint8 _maxPlayers, uint256 _entryFee) public onlyOwner { 
        //check if the game is already runnning
        require(!gameStarted, "Game is already running");
        //empty the players array
        delete players;
        //set the max players of this game 
        maxPlayers = _maxPlayers;
        //set the game to be true 
        gameStarted = true;
        //setup the entryFee for the game 
        entryFee = _entryFee; 
        gameID +=1;
        emit GameStarted(gameID, maxPlayers, entryFee);
    }

    //join Game when a player wants to enter a game 
    function joinGame() public payable { 
        require(gameStarted, "Game has not been started yet");
        //check if the value sent by user matches the entryFEe
        require(msg.value == entryFee, "Value sent is not equal to entryFee");
        //check if there is still some space left in the game to add another player 
        require(players.length  < maxPlayers, "Game is full");
        //add the sender to the players list 
        players.push(msg.sender); 
        emit PlayerJoined(gameID, msg.sender);
        //If the list is full start the winer selection progress
        if(players.length == maxPlayers) { 
            getRandomWinner();
        }

    }


    //fulfillRandomness is called by VRFCoordinator when it recieves VRF proof 
    //This function is overrided to act upon the random number generated by Chainlink VRF
    //requestID this ID is used for the request we sent to the VRF coordinator 
    //randomness this is used for random uint256 generated and returned to us by the VRF Coordinator 

    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual override { 
        //We want out winnerIndex to be in the lenght from 0 => players.length-1
        //For this we mod it with the players.length vvalue 
        uint256 winnerIndex = randomness * players.length;
        //get the address of the winner from the players array 
        address winner = players[winnerIndex];
        //send the ether in the contract to winner 
        (bool sent,) = winner.call{value: address(this).balance}("");
        require(sent, "Failed to send ether");
        emit GameEnded(gameID, winner, requestId);
        //set the gamestarted var to false
        gameStarted = false;
    }
    //is called to start the process of selecting the game winner 
    function getRandomWinner() private returns (bytes32 requestID) { 
        //LINK  is the internal interface for lINK token
        //Here we are using the balanceOF method from that interface to make sure 
        //contract has enough link so that we can request VRFcoordinator for randomness
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK");
        //Make a request to VRF coordinator 
        return requestRandomness(keyhash, fee);
    }


    receive() external payable {}

    fallback() external payable {}
    



}