//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import 'hardhat/console.sol';
import '@chainlink/contracts/src/v0.8/KeeperCompatible.sol';
import '@openzeppelin/contracts/utils/Counters.sol';

contract LuckyDraw is KeeperCompatible {
  using Counters for Counters.Counter;
  Counters.Counter private _luckyDrawIdCounter;

  enum LUCKYDRAW_STATE {
    OPEN,
    CLOSED,
    CALCULATING_WINNER
  }
  LUCKYDRAW_STATE public luckyDrawState;
  address payable[] public players;
  uint256 public luckyDrawId;

  // .01 ETH
  uint256 public MINIMUM = 1000000000000000;

  /**
   * Use an interval in seconds and a timestamp to slow execution of Upkeep
   */
  uint256 public immutable interval;
  uint256 public lastTimeStamp;
  uint256 public expiredTimeStamp;

  constructor(uint256 updateInterval) {
    luckyDrawId = _luckyDrawIdCounter.current();

    luckyDrawState = LUCKYDRAW_STATE.CLOSED;

    interval = updateInterval;
    lastTimeStamp = block.timestamp;
    expiredTimeStamp = block.timestamp;
  }

  function startNewLuckyDraw(uint256 duration) public {
    require(
      luckyDrawState == LUCKYDRAW_STATE.CLOSED,
      "can't start a new lucky draw yet"
    );
    _luckyDrawIdCounter.increment();
    luckyDrawId = _luckyDrawIdCounter.current();

    luckyDrawState = LUCKYDRAW_STATE.OPEN;
    expiredTimeStamp = block.timestamp + duration;
  }

  // enter the lucky draw
  function enter() public payable {
    assert(msg.value == MINIMUM);
    assert(luckyDrawState == LUCKYDRAW_STATE.OPEN);
    players.push(payable(msg.sender));
  }

  function checkUpkeep(bytes calldata checkData)
    external
    view
    override
    returns (bool upkeepNeeded, bytes memory performData)
  {
    upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
    // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    performData = checkData;
  }

  function performUpkeep(bytes calldata performData) external override {
    //We highly recommend revalidating the upkeep in the performUpkeep function
    if ((block.timestamp - lastTimeStamp) > interval) {
      lastTimeStamp = block.timestamp;
    }
    if (lastTimeStamp > expiredTimeStamp) {
      luckyDrawState = LUCKYDRAW_STATE.CLOSED;
    }
    // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
  }
}
