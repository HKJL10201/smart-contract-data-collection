//SPDX-License-Identifier:MIT

pragma solidity ^0.8.7;
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";
import "./SafeMath.sol";

contract Lottery is VRFConsumerBase {

using SafeMath for uint256;


address public _owner;                                  // Deployer of the contract
address public _winner;
uint256 _amountRequiredToJoinLottery = 0.1 ether;       // amount required to join lotter
bool _lotteryStarted;                                   // checks whether lottery has started or not
uint256 _contractDeployTime;                            // time at which contract was deployed
uint256 _lotteryStartTime;                              // time at which lottery will start
uint256 _lotteryEndTime;                                // time at which lottery will end
address[] _participants;                                // number of users participated in the lottery
bytes32 internal keyHash;
uint256 internal fee;                                   // fee required to interact with chainlink using LINK token
uint256 public randomResult;                            // a random number generated by chainlink VRF



/**
     * Constructor inherits VRFConsumerBase
     * 
     * Network: Rinkeby
     * Chainlink VRF Coordinator address: 0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B
     * LINK token address:               0x01BE23585060835E02B77ef475b0Cc51aA1e0709
     * Key Hash: 0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311
     */


// constructor 
constructor() VRFConsumerBase(0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B,
                            0x01BE23585060835E02B77ef475b0Cc51aA1e0709)
{
    _owner = msg.sender;
    keyHash = 0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311;
    fee = 0.1 * 10 ** 18;
    _contractDeployTime = block.timestamp;
    _lotteryStartTime = _contractDeployTime.add(1 minutes);
    _lotteryEndTime = _lotteryStartTime.add(6 minutes);

}

// function to allow users to participate in the lottery 
function participateInLotery()external payable timeCheckForParticipation participateOnce{
    require(msg.value == _amountRequiredToJoinLottery,"ERR_PARTICIPATION_AMOUNT_MUST_BE_0.1_ETHER");
    _participants.push(msg.sender);


}

  // function called by the owner to announce the winner
function winnerAnouncement(uint256 _randomNumber) public onlyOwner returns(address){
    require(block.timestamp > _lotteryEndTime,"LOTERY WILL END SOON");
    uint256 _result = _randomNumber.mod(_participants.length).add(1);           // converting the random number 
    _winner = _participants[_result];
    return _winner;   
}

function sendEtherToWinner(address _winnerAddress) public onlyOwner payable{
  payable(_winnerAddress).transfer(address(this).balance);
}


// function to get a random number
function getRandomNumber() public onlyOwner returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= fee, "NOT_ENOUGH_LINK - FILL_CONTRACT_WITH_FAUCET");
        return requestRandomness(keyHash, fee);
    }

    /**
     * Callback function used by VRF Coordinator
     */
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        randomResult = randomness;
    }

  
    modifier timeCheckForParticipation(){                                      // modifier to check whether the Lottery participation
     _lotteryStarted = false;                                                  // has started

       if(block.timestamp >= _lotteryStartTime){
        _lotteryStarted = true;
    }

    require(_lotteryStarted,"WAIT FOR THE LOTERY TO START");
    require(block.timestamp < _lotteryEndTime,"ERR_LOTERY_PARTICIPATION_TIME_ENDED");
    _;
}

modifier participateOnce(){                                                     // modifier to restrict users from participating
    bool participated = false;                                                  // in lottery again
    for(uint i = 0; i < _participants.length ; i++){
        if(msg.sender == _participants[i]){
            participated = true;
        }
    }

    require(!participated,"ERR_CAN_PARTICIPATE_ONCE_PER_LOTERY");
    _;
}

modifier onlyOwner(){                                                           // only owner modifier
    require(msg.sender == _owner,"ERR_YOU_ARE_NOT_THE_OWNER");
    _;
}

receive() external payable{                                                     // receive function to receive ether

}

}